/**
 * Unified Ethereum HTLC Client
 * Replaces both ethereum-htlc-client.ts and ethereum-htlc-client-pooled.ts
 * Uses connection strategy pattern to eliminate duplication
 */

import { ethers } from 'ethers';
import { 
  BaseHTLCClient, 
  HTLCOperationParams, 
  HTLCOperationResult, 
  HTLCDetails,
  HTLCError,
  HTLCErrorCode,
  ConnectionStrategy
} from '@evmore/utils';
import { HTLC_ABI, ERC20_ABI } from '@evmore/utils';
import { validateAmount, validateAddress, isValidHash } from '../utils';
import { TransactionReceipt, PooledTransactionResult } from '../types';

/**
 * Ethereum configuration
 */
export interface EthereumConfig {
  htlcContract: string;
  resolverContract?: string;
  privateKey?: string;
  chainId: number;
  gasPrice?: string;
  gasLimit?: number;
}

/**
 * Ethereum HTLC creation parameters
 */
export interface CreateEthereumHTLCParams extends HTLCOperationParams {
  token: string; // Token contract address (or '0x0' for ETH)
  amount: string;
  receiver: string;
  hashlock: string;
  timelock: number;
  targetChain: string;
  targetAddress: string;
}

/**
 * Unified Ethereum HTLC Client
 * Works with both direct and pooled connections
 */
export class EthereumHTLCClient extends BaseHTLCClient<ethers.providers.JsonRpcProvider> {
  private wallet?: ethers.Wallet;

  constructor(
    config: EthereumConfig,
    connectionStrategy: ConnectionStrategy<ethers.providers.JsonRpcProvider>
  ) {
    super(config, connectionStrategy);
    
    if (config.privateKey) {
      this.wallet = new ethers.Wallet(config.privateKey);
    }
  }

  /**
   * Generate deterministic HTLC ID
   */
  protected generateHTLCId(params: HTLCOperationParams): string {
    // For Ethereum, the HTLC ID is generated by the contract
    // This is a placeholder for TypeScript compliance
    return ethers.utils.id(`${params.receiver}_${params.hashlock}_${params.timelock}`);
  }

  /**
   * Create HTLC on Ethereum
   */
  public async createHTLC(params: CreateEthereumHTLCParams): Promise<HTLCOperationResult> {
    this.validateHTLCParams(params);
    
    if (!validateAddress(params.receiver, 'ethereum')) {
      throw new HTLCError('Invalid receiver address', HTLCErrorCode.INVALID_PARAMS);
    }

    if (!validateAddress(params.token, 'ethereum')) {
      throw new HTLCError('Invalid token address', HTLCErrorCode.INVALID_PARAMS);
    }

    return await this.executeWithConnection(async (provider) => {
      if (!this.wallet) {
        throw new HTLCError('Private key required for creating HTLC', HTLCErrorCode.INVALID_PARAMS);
      }

      const signer = this.wallet.connect(provider);
      const contract = new ethers.Contract(this.config.htlcContract, HTLC_ABI, signer);

      // Handle ERC20 token approval if needed
      if (params.token !== ethers.constants.AddressZero) {
        await this.approveTokenIfNeeded(params.token, params.amount, provider);
      }

      try {
        const tx = await contract.createHTLC(
          params.token,
          ethers.utils.parseUnits(params.amount, 18), // Assume 18 decimals, could be configurable
          params.hashlock,
          params.timelock,
          params.targetChain,
          params.targetAddress,
          {
            gasLimit: this.config.gasLimit || 200000,
            gasPrice: this.config.gasPrice ? ethers.utils.parseUnits(this.config.gasPrice, 'gwei') : undefined,
            value: params.token === ethers.constants.AddressZero ? ethers.utils.parseUnits(params.amount, 18) : 0
          }
        );

        const receipt = await tx.wait();
        
        // Extract HTLC ID from logs
        const htlcCreatedLog = receipt.logs.find((log: any) => {
          try {
            const parsed = contract.interface.parseLog(log);
            return parsed?.name === 'HTLCCreated';
          } catch {
            return false;
          }
        });

        let htlcId = '';
        if (htlcCreatedLog) {
          const parsed = contract.interface.parseLog(htlcCreatedLog);
          htlcId = parsed?.args?.htlcId || '';
        }

        return {
          transactionHash: receipt.hash,
          htlcId,
          blockNumber: receipt.blockNumber,
          gasUsed: receipt.gasUsed.toString(),
          success: receipt.status === 1
        };
      } catch (error: any) {
        throw new HTLCError(
          `Failed to create HTLC: ${error.message}`,
          HTLCErrorCode.TRANSACTION_FAILED
        );
      }
    });
  }

  /**
   * Withdraw from HTLC
   */
  public async withdraw(htlcId: string, secret: string): Promise<HTLCOperationResult> {
    if (!isValidHash(secret.replace('0x', ''))) {
      throw new HTLCError('Invalid secret format', HTLCErrorCode.INVALID_PARAMS);
    }

    return await this.executeWithConnection(async (provider) => {
      if (!this.wallet) {
        throw new HTLCError('Private key required for withdrawal', HTLCErrorCode.INVALID_PARAMS);
      }

      const signer = this.wallet.connect(provider);
      const contract = new ethers.Contract(this.config.htlcContract, HTLC_ABI, signer);

      try {
        const tx = await contract.withdraw(htlcId, secret, {
          gasLimit: this.config.gasLimit || 100000,
          gasPrice: this.config.gasPrice ? ethers.utils.parseUnits(this.config.gasPrice, 'gwei') : undefined
        });

        const receipt = await tx.wait();

        return {
          transactionHash: receipt.hash,
          htlcId,
          blockNumber: receipt.blockNumber,
          gasUsed: receipt.gasUsed.toString(),
          success: receipt.status === 1
        };
      } catch (error: any) {
        throw new HTLCError(
          `Failed to withdraw HTLC: ${error.message}`,
          HTLCErrorCode.TRANSACTION_FAILED,
          htlcId
        );
      }
    });
  }

  /**
   * Refund HTLC
   */
  public async refund(htlcId: string): Promise<HTLCOperationResult> {
    return await this.executeWithConnection(async (provider) => {
      if (!this.wallet) {
        throw new HTLCError('Private key required for refund', HTLCErrorCode.INVALID_PARAMS);
      }

      const signer = this.wallet.connect(provider);
      const contract = new ethers.Contract(this.config.htlcContract, HTLC_ABI, signer);

      try {
        const tx = await contract.refund(htlcId, {
          gasLimit: this.config.gasLimit || 80000,
          gasPrice: this.config.gasPrice ? ethers.utils.parseUnits(this.config.gasPrice, 'gwei') : undefined
        });

        const receipt = await tx.wait();

        return {
          transactionHash: receipt.hash,
          htlcId,
          blockNumber: receipt.blockNumber,
          gasUsed: receipt.gasUsed.toString(),
          success: receipt.status === 1
        };
      } catch (error: any) {
        throw new HTLCError(
          `Failed to refund HTLC: ${error.message}`,
          HTLCErrorCode.TRANSACTION_FAILED,
          htlcId
        );
      }
    });
  }

  /**
   * Get HTLC details
   */
  public async getHTLC(htlcId: string): Promise<HTLCDetails> {
    return await this.executeWithConnection(async (provider) => {
      const contract = new ethers.Contract(this.config.htlcContract, HTLC_ABI, provider);

      try {
        const result = await contract.getHTLC(htlcId);
        
        return {
          htlcId,
          sender: result.sender,
          receiver: result.receiver || result.sender, // Fallback if receiver not in ABI
          token: result.token,
          amount: ethers.utils.formatUnits(result.amount, 18),
          hashlock: result.hashlock,
          timelock: Number(result.timelock),
          withdrawn: result.withdrawn,
          refunded: result.refunded,
          targetChain: result.targetChain,
          targetAddress: result.targetAddress,
          createdAt: new Date(), // Could be derived from blockchain
          expiresAt: this.calculateExpiration(Number(result.timelock))
        };
      } catch (error: any) {
        throw new HTLCError(
          `Failed to get HTLC details: ${error.message}`,
          HTLCErrorCode.HTLC_NOT_FOUND,
          htlcId
        );
      }
    });
  }

  /**
   * Check if HTLC exists
   */
  public async htlcExists(htlcId: string): Promise<boolean> {
    try {
      await this.getHTLC(htlcId);
      return true;
    } catch (error) {
      if (error instanceof HTLCError && error.code === HTLCErrorCode.HTLC_NOT_FOUND) {
        return false;
      }
      throw error;
    }
  }

  /**
   * Get ERC20 token balance
   */
  public async getTokenBalance(tokenAddress: string, userAddress: string): Promise<string> {
    return await this.executeWithConnection(async (provider) => {
      if (tokenAddress === ethers.constants.AddressZero) {
        // ETH balance
        const balance = await provider.getBalance(userAddress);
        return ethers.utils.formatEther(balance);
      } else {
        // ERC20 balance
        const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
        const balance = await contract.balanceOf(userAddress);
        const decimals = await contract.decimals();
        return ethers.utils.formatUnits(balance, decimals);
      }
    });
  }

  /**
   * Approve ERC20 token spending if needed
   */
  private async approveTokenIfNeeded(
    tokenAddress: string,
    amount: string,
    provider: ethers.providers.JsonRpcProvider
  ): Promise<void> {
    if (!this.wallet) return;

    const signer = this.wallet.connect(provider);
    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
    
    const allowance = await contract.allowance(
      await signer.getAddress(),
      this.config.htlcContract
    );
    
    const requiredAmount = ethers.utils.parseUnits(amount, 18);
    
    if (allowance < requiredAmount) {
      const approveTx = await contract.approve(this.config.htlcContract, requiredAmount);
      await approveTx.wait();
    }
  }

  /**
   * Estimate gas for HTLC creation
   */
  public async estimateCreateHTLCGas(params: CreateEthereumHTLCParams): Promise<string> {
    return await this.executeWithConnection(async (provider) => {
      const contract = new ethers.Contract(this.config.htlcContract, HTLC_ABI, provider);
      
      try {
        const gasEstimate = await contract.createHTLC.estimateGas(
          params.token,
          ethers.utils.parseUnits(params.amount, 18),
          params.hashlock,
          params.timelock,
          params.targetChain,
          params.targetAddress,
          {
            value: params.token === ethers.constants.AddressZero ? ethers.utils.parseUnits(params.amount, 18) : 0
          }
        );
        
        return gasEstimate.toString();
      } catch (error: any) {
        throw new HTLCError(
          `Failed to estimate gas: ${error.message}`,
          HTLCErrorCode.TRANSACTION_FAILED
        );
      }
    });
  }
}

// Factory functions for backward compatibility
export function createEthereumHTLCClient(config: EthereumConfig): EthereumHTLCClient {
  const { ConnectionStrategyFactory } = require('@evmore/utils');
  const strategy = ConnectionStrategyFactory.createEthereumStrategy('direct', {
    rpcUrl: `https://mainnet.infura.io/v3/${process.env.INFURA_API_KEY}` // Should come from config
  });
  return new EthereumHTLCClient(config, strategy);
}

export function createPooledEthereumHTLCClient(
  config: EthereumConfig,
  connectionPool: any
): EthereumHTLCClient {
  const { ConnectionStrategyFactory } = require('@evmore/utils');
  const strategy = ConnectionStrategyFactory.createEthereumStrategy('pooled', {
    connectionPool
  });
  return new EthereumHTLCClient(config, strategy);
}

// Legacy type exports for backward compatibility
export type { TransactionReceipt, PooledTransactionResult };
export { HTLCError, HTLCErrorCode };